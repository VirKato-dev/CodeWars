package a.streams;

import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;

/**
 * Если все потоки ForkJoinPool заняты,
 * то методы parallel() и parallelStream() вернут не параллельный стрим, а последовательный.
 */
public class ParallelStreamExample {

    // Как сделать, чтобы гарантированно распараллелить стрим? Просто - создать свой пул потоков.
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ForkJoinPool pool = new ForkJoinPool(3);
        List<Integer> list = List.of(1, 2, 3);

        pool.submit(() -> list.parallelStream()
                .map(e -> e * 2)
                .forEach(System.out::println)
        ).get();
        pool.shutdown();
    }
}

/*
Несмотря на внешнюю лаконичность параллельных стримов, они могут сильно влиять на производительность:
потоки вашего стрима могут отнимать процессорное время у соседних потоков,
частое переключение между потоками ведет к частой смене контекста исполнения.

Поэтому использовать параллельные стримы нужно только при сильной необходимости и с подходящими задачами.
Какие задачи можно считать подходящими?

- те, что не зависят от соседних задач и, которым необходим только один элемент стрима

- те, что используют источник данных, который можно вычитывать в несколько потоков

- те, которые тратят много времени для работы с каждым элементом,
  иначе расходы на обслуживание потоков могут "съесть" прирост производительности от параллельности

- те, что не требуют больших затрат на соединение результатов работы каждого потока
 */
