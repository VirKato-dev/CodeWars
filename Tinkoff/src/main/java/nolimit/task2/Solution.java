package nolimit.task2;

import java.util.Scanner;

/**
 * Ваня принес на кухню рулет, который он хочет разделить с коллегами.
 * Для этого он хочет разрезать рулет на N равных частей.
 * Разумеется, рулет можно резать только поперек.
 * Соотвественно, Костя сделает N−1 разрез ножом через равные промежутки.
 * <p>
 * По возвращению с кофе-брейка Ваня задумался — а можно ли было обойтись меньшим числом движений,
 * будь нож Вани бесконечно длинным (иначе говоря, если он мог бы сделать сколько угодно разрезов за раз,
 * если эти разрезы лежат на одной прямой)?
 * Считается, что места для разрезов намечены заранее, и все разрезы делаются с ювелирной точностью.
 * <p>
 * Оказывается, что можно. Например, если Ваня хотел бы разделить рулет на 4 части,
 * он мог бы обойтись двумя разрезами — сначала он разделил бы рулет на две половинки,
 * а потом совместил бы две половинки и разрезал обе пополам одновременно.
 * <p>
 * Вам дано число N, требуется сказать, каким минимальным числом разрезов можно обойтись.
 * <p>
 * Чтобы разрезать рулет на 6 частей,
 * Ване сначала придется разрезать его на две равные части,
 * после чего совместить две половинки и сделать два разреза.
 * <p>
 * Чтобы разрезать рулет на 5 частей,
 * Ване понадобится разделить его в соотношении 2:3,
 * после чего совместить два рулета по левому краю
 * и разрезать бОльший рулет на одинарные кусочки
 * — меньший тоже разделится на одинарные.
 */
public class Solution {

    // 1 - 0

    // 2 - 1 (1/2)

    // 3 - 2 (2/3,1/2)       - отсечь неполную половину
    // 4 - 2 (1/2,1/2)

    // 5 - 3 (3/5,2/3,1/2)   - отсечь неполную половину
    // 6 - 3 (1/2,2/3,1/2)
    // 7 - 3 (4/7,1/2,1/2)   - отсечь неполную половину
    // 8 - 3 (1/2,1/2,1/2)

    // 9 - 4 (5/9,3/5,2/3,1/2)


    public static void main(String[] args) {
//        Scanner in = new Scanner(System.in);
        Scanner in = new Scanner("5"); // 4
        System.out.println(option5(in.nextInt()));
    }

    private static int option1(int parts) { // 0.127 // 0.094
        // при нечётном режем от середины на одну дольку больше
        int step = 0;
        while (parts > 1) {
            step++;
//            parts = parts / 2 + parts % 2;
            parts = (parts >> 1) + (parts & 1);
        }
        return step;
    }

    private static int option2(int parts) { // 0.120
        // логарифм числа b по основанию a  --  log a b = ln(b) / ln(a)
        // степень двойки для указанного числа говорит о количестве необходимых разрезов
        // степень всегда округлять в бОльшую сторону
        return (int) Math.ceil(Math.log(parts) / Math.log(2));
    }

    private static int option3(int parts) { // 0.103
        parts--;
        int step = 0;
        while (parts > 0) {
            step++;
            parts >>= 1;
        }
        return step;
    }

    private static int option4(int parts) { // 0.077
        return 32 - Integer.numberOfLeadingZeros(--parts);
    }

    private static int option5(int parts) { // 0.120
        --parts;
        int n;
        if (parts <= 0) {
            n = parts == 0 ? 0 : 32;
        } else {
            n = 1;
            if (parts >= 65536) {
                n += 16;
                parts >>>= 16;
            }

            if (parts >= 256) {
                n += 8;
                parts >>>= 8;
            }

            if (parts >= 16) {
                n += 4;
                parts >>>= 4;
            }

            if (parts >= 4) {
                n += 2;
                parts >>>= 2;
            }

            n += (parts >>> 1);
        }
        return n;
    }
}
